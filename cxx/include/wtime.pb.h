// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: wtime.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_wtime_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_wtime_2eproto

#include <limits>
#include "internal/times_internal.h"

#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_wtime_2eproto TIMES_API
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TIMES_API TableStruct_wtime_2eproto {
  static const uint32_t offsets[];
};
TIMES_API extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_wtime_2eproto;
namespace HSS {
namespace Times {
class WTime;
struct WTimeDefaultTypeInternal;
TIMES_API extern WTimeDefaultTypeInternal _WTime_default_instance_;
class WTimeSpan;
struct WTimeSpanDefaultTypeInternal;
TIMES_API extern WTimeSpanDefaultTypeInternal _WTimeSpan_default_instance_;
class WTimeZone;
struct WTimeZoneDefaultTypeInternal;
TIMES_API extern WTimeZoneDefaultTypeInternal _WTimeZone_default_instance_;
class WTimeZone_TZTimeZone;
struct WTimeZone_TZTimeZoneDefaultTypeInternal;
TIMES_API extern WTimeZone_TZTimeZoneDefaultTypeInternal _WTimeZone_TZTimeZone_default_instance_;
class WTimeZone_WTZDetails;
struct WTimeZone_WTZDetailsDefaultTypeInternal;
TIMES_API extern WTimeZone_WTZDetailsDefaultTypeInternal _WTimeZone_WTZDetails_default_instance_;
}  // namespace Times
}  // namespace HSS
PROTOBUF_NAMESPACE_OPEN
template<> TIMES_API ::HSS::Times::WTime* Arena::CreateMaybeMessage<::HSS::Times::WTime>(Arena*);
template<> TIMES_API ::HSS::Times::WTimeSpan* Arena::CreateMaybeMessage<::HSS::Times::WTimeSpan>(Arena*);
template<> TIMES_API ::HSS::Times::WTimeZone* Arena::CreateMaybeMessage<::HSS::Times::WTimeZone>(Arena*);
template<> TIMES_API ::HSS::Times::WTimeZone_TZTimeZone* Arena::CreateMaybeMessage<::HSS::Times::WTimeZone_TZTimeZone>(Arena*);
template<> TIMES_API ::HSS::Times::WTimeZone_WTZDetails* Arena::CreateMaybeMessage<::HSS::Times::WTimeZone_WTZDetails>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace HSS {
namespace Times {

// ===================================================================

class TIMES_API WTime final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HSS.Times.WTime) */ {
 public:
  inline WTime() : WTime(nullptr) {}
  ~WTime() override;
  explicit PROTOBUF_CONSTEXPR WTime(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WTime(const WTime& from);
  WTime(WTime&& from) noexcept
    : WTime() {
    *this = ::std::move(from);
  }

  inline WTime& operator=(const WTime& from) {
    CopyFrom(from);
    return *this;
  }
  inline WTime& operator=(WTime&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WTime& default_instance() {
    return *internal_default_instance();
  }
  static inline const WTime* internal_default_instance() {
    return reinterpret_cast<const WTime*>(
               &_WTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(WTime& a, WTime& b) {
    a.Swap(&b);
  }
  inline void Swap(WTime* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WTime* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WTime* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WTime>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WTime& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WTime& from) {
    WTime::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WTime* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HSS.Times.WTime";
  }
  protected:
  explicit WTime(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeFieldNumber = 1,
    kDaylightFieldNumber = 2,
    kTimezoneFieldNumber = 3,
    kTimezoneIdFieldNumber = 4,
  };
  // string time = 1;
  void clear_time();
  const std::string& time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time();
  PROTOBUF_NODISCARD std::string* release_time();
  void set_allocated_time(std::string* time);
  private:
  const std::string& _internal_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time(const std::string& value);
  std::string* _internal_mutable_time();
  public:

  // .google.protobuf.StringValue daylight = 2;
  bool has_daylight() const;
  private:
  bool _internal_has_daylight() const;
  public:
  void clear_daylight();
  const ::PROTOBUF_NAMESPACE_ID::StringValue& daylight() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_daylight();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_daylight();
  void set_allocated_daylight(::PROTOBUF_NAMESPACE_ID::StringValue* daylight);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_daylight() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_daylight();
  public:
  void unsafe_arena_set_allocated_daylight(
      ::PROTOBUF_NAMESPACE_ID::StringValue* daylight);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_daylight();

  // .google.protobuf.StringValue timezone = 3;
  bool has_timezone() const;
  private:
  bool _internal_has_timezone() const;
  public:
  void clear_timezone();
  const ::PROTOBUF_NAMESPACE_ID::StringValue& timezone() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_timezone();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_timezone();
  void set_allocated_timezone(::PROTOBUF_NAMESPACE_ID::StringValue* timezone);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_timezone() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_timezone();
  public:
  void unsafe_arena_set_allocated_timezone(
      ::PROTOBUF_NAMESPACE_ID::StringValue* timezone);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_timezone();

  // .google.protobuf.Int32Value timezone_id = 4 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_timezone_id() const;
  private:
  bool _internal_has_timezone_id() const;
  public:
  PROTOBUF_DEPRECATED void clear_timezone_id();
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::Int32Value& timezone_id() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::Int32Value* release_timezone_id();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::Int32Value* mutable_timezone_id();
  PROTOBUF_DEPRECATED void set_allocated_timezone_id(::PROTOBUF_NAMESPACE_ID::Int32Value* timezone_id);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Int32Value& _internal_timezone_id() const;
  ::PROTOBUF_NAMESPACE_ID::Int32Value* _internal_mutable_timezone_id();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_timezone_id(
      ::PROTOBUF_NAMESPACE_ID::Int32Value* timezone_id);
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::Int32Value* unsafe_arena_release_timezone_id();

  // @@protoc_insertion_point(class_scope:HSS.Times.WTime)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_;
    ::PROTOBUF_NAMESPACE_ID::StringValue* daylight_;
    ::PROTOBUF_NAMESPACE_ID::StringValue* timezone_;
    ::PROTOBUF_NAMESPACE_ID::Int32Value* timezone_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_wtime_2eproto;
};
// -------------------------------------------------------------------

class TIMES_API WTimeSpan final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HSS.Times.WTimeSpan) */ {
 public:
  inline WTimeSpan() : WTimeSpan(nullptr) {}
  ~WTimeSpan() override;
  explicit PROTOBUF_CONSTEXPR WTimeSpan(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WTimeSpan(const WTimeSpan& from);
  WTimeSpan(WTimeSpan&& from) noexcept
    : WTimeSpan() {
    *this = ::std::move(from);
  }

  inline WTimeSpan& operator=(const WTimeSpan& from) {
    CopyFrom(from);
    return *this;
  }
  inline WTimeSpan& operator=(WTimeSpan&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WTimeSpan& default_instance() {
    return *internal_default_instance();
  }
  static inline const WTimeSpan* internal_default_instance() {
    return reinterpret_cast<const WTimeSpan*>(
               &_WTimeSpan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(WTimeSpan& a, WTimeSpan& b) {
    a.Swap(&b);
  }
  inline void Swap(WTimeSpan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WTimeSpan* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WTimeSpan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WTimeSpan>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WTimeSpan& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WTimeSpan& from) {
    WTimeSpan::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WTimeSpan* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HSS.Times.WTimeSpan";
  }
  protected:
  explicit WTimeSpan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeFieldNumber = 1,
  };
  // string time = 1;
  void clear_time();
  const std::string& time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time();
  PROTOBUF_NODISCARD std::string* release_time();
  void set_allocated_time(std::string* time);
  private:
  const std::string& _internal_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time(const std::string& value);
  std::string* _internal_mutable_time();
  public:

  // @@protoc_insertion_point(class_scope:HSS.Times.WTimeSpan)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_wtime_2eproto;
};
// -------------------------------------------------------------------

class TIMES_API WTimeZone_WTZDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HSS.Times.WTimeZone.WTZDetails) */ {
 public:
  inline WTimeZone_WTZDetails() : WTimeZone_WTZDetails(nullptr) {}
  ~WTimeZone_WTZDetails() override;
  explicit PROTOBUF_CONSTEXPR WTimeZone_WTZDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WTimeZone_WTZDetails(const WTimeZone_WTZDetails& from);
  WTimeZone_WTZDetails(WTimeZone_WTZDetails&& from) noexcept
    : WTimeZone_WTZDetails() {
    *this = ::std::move(from);
  }

  inline WTimeZone_WTZDetails& operator=(const WTimeZone_WTZDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline WTimeZone_WTZDetails& operator=(WTimeZone_WTZDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WTimeZone_WTZDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const WTimeZone_WTZDetails* internal_default_instance() {
    return reinterpret_cast<const WTimeZone_WTZDetails*>(
               &_WTimeZone_WTZDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(WTimeZone_WTZDetails& a, WTimeZone_WTZDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(WTimeZone_WTZDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WTimeZone_WTZDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WTimeZone_WTZDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WTimeZone_WTZDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WTimeZone_WTZDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WTimeZone_WTZDetails& from) {
    WTimeZone_WTZDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WTimeZone_WTZDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HSS.Times.WTimeZone.WTZDetails";
  }
  protected:
  explicit WTimeZone_WTZDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAmtTimeZoneFieldNumber = 1,
    kStartDSTFieldNumber = 2,
    kEndDSTFieldNumber = 3,
    kAmtDSTFieldNumber = 4,
  };
  // .HSS.Times.WTimeSpan amtTimeZone = 1;
  bool has_amttimezone() const;
  private:
  bool _internal_has_amttimezone() const;
  public:
  void clear_amttimezone();
  const ::HSS::Times::WTimeSpan& amttimezone() const;
  PROTOBUF_NODISCARD ::HSS::Times::WTimeSpan* release_amttimezone();
  ::HSS::Times::WTimeSpan* mutable_amttimezone();
  void set_allocated_amttimezone(::HSS::Times::WTimeSpan* amttimezone);
  private:
  const ::HSS::Times::WTimeSpan& _internal_amttimezone() const;
  ::HSS::Times::WTimeSpan* _internal_mutable_amttimezone();
  public:
  void unsafe_arena_set_allocated_amttimezone(
      ::HSS::Times::WTimeSpan* amttimezone);
  ::HSS::Times::WTimeSpan* unsafe_arena_release_amttimezone();

  // .HSS.Times.WTimeSpan startDST = 2;
  bool has_startdst() const;
  private:
  bool _internal_has_startdst() const;
  public:
  void clear_startdst();
  const ::HSS::Times::WTimeSpan& startdst() const;
  PROTOBUF_NODISCARD ::HSS::Times::WTimeSpan* release_startdst();
  ::HSS::Times::WTimeSpan* mutable_startdst();
  void set_allocated_startdst(::HSS::Times::WTimeSpan* startdst);
  private:
  const ::HSS::Times::WTimeSpan& _internal_startdst() const;
  ::HSS::Times::WTimeSpan* _internal_mutable_startdst();
  public:
  void unsafe_arena_set_allocated_startdst(
      ::HSS::Times::WTimeSpan* startdst);
  ::HSS::Times::WTimeSpan* unsafe_arena_release_startdst();

  // .HSS.Times.WTimeSpan endDST = 3;
  bool has_enddst() const;
  private:
  bool _internal_has_enddst() const;
  public:
  void clear_enddst();
  const ::HSS::Times::WTimeSpan& enddst() const;
  PROTOBUF_NODISCARD ::HSS::Times::WTimeSpan* release_enddst();
  ::HSS::Times::WTimeSpan* mutable_enddst();
  void set_allocated_enddst(::HSS::Times::WTimeSpan* enddst);
  private:
  const ::HSS::Times::WTimeSpan& _internal_enddst() const;
  ::HSS::Times::WTimeSpan* _internal_mutable_enddst();
  public:
  void unsafe_arena_set_allocated_enddst(
      ::HSS::Times::WTimeSpan* enddst);
  ::HSS::Times::WTimeSpan* unsafe_arena_release_enddst();

  // .HSS.Times.WTimeSpan amtDST = 4;
  bool has_amtdst() const;
  private:
  bool _internal_has_amtdst() const;
  public:
  void clear_amtdst();
  const ::HSS::Times::WTimeSpan& amtdst() const;
  PROTOBUF_NODISCARD ::HSS::Times::WTimeSpan* release_amtdst();
  ::HSS::Times::WTimeSpan* mutable_amtdst();
  void set_allocated_amtdst(::HSS::Times::WTimeSpan* amtdst);
  private:
  const ::HSS::Times::WTimeSpan& _internal_amtdst() const;
  ::HSS::Times::WTimeSpan* _internal_mutable_amtdst();
  public:
  void unsafe_arena_set_allocated_amtdst(
      ::HSS::Times::WTimeSpan* amtdst);
  ::HSS::Times::WTimeSpan* unsafe_arena_release_amtdst();

  // @@protoc_insertion_point(class_scope:HSS.Times.WTimeZone.WTZDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::HSS::Times::WTimeSpan* amttimezone_;
    ::HSS::Times::WTimeSpan* startdst_;
    ::HSS::Times::WTimeSpan* enddst_;
    ::HSS::Times::WTimeSpan* amtdst_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_wtime_2eproto;
};
// -------------------------------------------------------------------

class TIMES_API WTimeZone_TZTimeZone final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HSS.Times.WTimeZone.TZTimeZone) */ {
 public:
  inline WTimeZone_TZTimeZone() : WTimeZone_TZTimeZone(nullptr) {}
  ~WTimeZone_TZTimeZone() override;
  explicit PROTOBUF_CONSTEXPR WTimeZone_TZTimeZone(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WTimeZone_TZTimeZone(const WTimeZone_TZTimeZone& from);
  WTimeZone_TZTimeZone(WTimeZone_TZTimeZone&& from) noexcept
    : WTimeZone_TZTimeZone() {
    *this = ::std::move(from);
  }

  inline WTimeZone_TZTimeZone& operator=(const WTimeZone_TZTimeZone& from) {
    CopyFrom(from);
    return *this;
  }
  inline WTimeZone_TZTimeZone& operator=(WTimeZone_TZTimeZone&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WTimeZone_TZTimeZone& default_instance() {
    return *internal_default_instance();
  }
  static inline const WTimeZone_TZTimeZone* internal_default_instance() {
    return reinterpret_cast<const WTimeZone_TZTimeZone*>(
               &_WTimeZone_TZTimeZone_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(WTimeZone_TZTimeZone& a, WTimeZone_TZTimeZone& b) {
    a.Swap(&b);
  }
  inline void Swap(WTimeZone_TZTimeZone* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WTimeZone_TZTimeZone* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WTimeZone_TZTimeZone* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WTimeZone_TZTimeZone>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WTimeZone_TZTimeZone& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WTimeZone_TZTimeZone& from) {
    WTimeZone_TZTimeZone::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WTimeZone_TZTimeZone* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HSS.Times.WTimeZone.TZTimeZone";
  }
  protected:
  explicit WTimeZone_TZTimeZone(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDaylightFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional bool daylight = 2;
  bool has_daylight() const;
  private:
  bool _internal_has_daylight() const;
  public:
  void clear_daylight();
  bool daylight() const;
  void set_daylight(bool value);
  private:
  bool _internal_daylight() const;
  void _internal_set_daylight(bool value);
  public:

  // @@protoc_insertion_point(class_scope:HSS.Times.WTimeZone.TZTimeZone)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    bool daylight_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_wtime_2eproto;
};
// -------------------------------------------------------------------

class TIMES_API WTimeZone final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HSS.Times.WTimeZone) */ {
 public:
  inline WTimeZone() : WTimeZone(nullptr) {}
  ~WTimeZone() override;
  explicit PROTOBUF_CONSTEXPR WTimeZone(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WTimeZone(const WTimeZone& from);
  WTimeZone(WTimeZone&& from) noexcept
    : WTimeZone() {
    *this = ::std::move(from);
  }

  inline WTimeZone& operator=(const WTimeZone& from) {
    CopyFrom(from);
    return *this;
  }
  inline WTimeZone& operator=(WTimeZone&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WTimeZone& default_instance() {
    return *internal_default_instance();
  }
  enum MsgCase {
    kTimezoneIndex = 2,
    kTimezoneDetails = 3,
    kTztimezone = 4,
    MSG_NOT_SET = 0,
  };

  static inline const WTimeZone* internal_default_instance() {
    return reinterpret_cast<const WTimeZone*>(
               &_WTimeZone_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(WTimeZone& a, WTimeZone& b) {
    a.Swap(&b);
  }
  inline void Swap(WTimeZone* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WTimeZone* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WTimeZone* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WTimeZone>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WTimeZone& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WTimeZone& from) {
    WTimeZone::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WTimeZone* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HSS.Times.WTimeZone";
  }
  protected:
  explicit WTimeZone(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef WTimeZone_WTZDetails WTZDetails;
  typedef WTimeZone_TZTimeZone TZTimeZone;

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kTimezoneIndexFieldNumber = 2,
    kTimezoneDetailsFieldNumber = 3,
    kTztimezoneFieldNumber = 4,
  };
  // int32 version = 1;
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // int32 timezoneIndex = 2 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_timezoneindex() const;
  private:
  bool _internal_has_timezoneindex() const;
  public:
  PROTOBUF_DEPRECATED void clear_timezoneindex();
  PROTOBUF_DEPRECATED int32_t timezoneindex() const;
  PROTOBUF_DEPRECATED void set_timezoneindex(int32_t value);
  private:
  int32_t _internal_timezoneindex() const;
  void _internal_set_timezoneindex(int32_t value);
  public:

  // .HSS.Times.WTimeZone.WTZDetails timezoneDetails = 3 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_timezonedetails() const;
  private:
  bool _internal_has_timezonedetails() const;
  public:
  PROTOBUF_DEPRECATED void clear_timezonedetails();
  PROTOBUF_DEPRECATED const ::HSS::Times::WTimeZone_WTZDetails& timezonedetails() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::HSS::Times::WTimeZone_WTZDetails* release_timezonedetails();
  PROTOBUF_DEPRECATED ::HSS::Times::WTimeZone_WTZDetails* mutable_timezonedetails();
  PROTOBUF_DEPRECATED void set_allocated_timezonedetails(::HSS::Times::WTimeZone_WTZDetails* timezonedetails);
  private:
  const ::HSS::Times::WTimeZone_WTZDetails& _internal_timezonedetails() const;
  ::HSS::Times::WTimeZone_WTZDetails* _internal_mutable_timezonedetails();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_timezonedetails(
      ::HSS::Times::WTimeZone_WTZDetails* timezonedetails);
  PROTOBUF_DEPRECATED ::HSS::Times::WTimeZone_WTZDetails* unsafe_arena_release_timezonedetails();

  // .HSS.Times.WTimeZone.TZTimeZone tztimezone = 4;
  bool has_tztimezone() const;
  private:
  bool _internal_has_tztimezone() const;
  public:
  void clear_tztimezone();
  const ::HSS::Times::WTimeZone_TZTimeZone& tztimezone() const;
  PROTOBUF_NODISCARD ::HSS::Times::WTimeZone_TZTimeZone* release_tztimezone();
  ::HSS::Times::WTimeZone_TZTimeZone* mutable_tztimezone();
  void set_allocated_tztimezone(::HSS::Times::WTimeZone_TZTimeZone* tztimezone);
  private:
  const ::HSS::Times::WTimeZone_TZTimeZone& _internal_tztimezone() const;
  ::HSS::Times::WTimeZone_TZTimeZone* _internal_mutable_tztimezone();
  public:
  void unsafe_arena_set_allocated_tztimezone(
      ::HSS::Times::WTimeZone_TZTimeZone* tztimezone);
  ::HSS::Times::WTimeZone_TZTimeZone* unsafe_arena_release_tztimezone();

  void clear_msg();
  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:HSS.Times.WTimeZone)
 private:
  class _Internal;
  void set_has_timezoneindex();
  void set_has_timezonedetails();
  void set_has_tztimezone();

  inline bool has_msg() const;
  inline void clear_has_msg();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t version_;
    union MsgUnion {
      constexpr MsgUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int32_t timezoneindex_;
      ::HSS::Times::WTimeZone_WTZDetails* timezonedetails_;
      ::HSS::Times::WTimeZone_TZTimeZone* tztimezone_;
    } msg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_wtime_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// WTime

// string time = 1;
inline void WTime::clear_time() {
  _impl_.time_.ClearToEmpty();
}
inline const std::string& WTime::time() const {
  // @@protoc_insertion_point(field_get:HSS.Times.WTime.time)
  return _internal_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WTime::set_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HSS.Times.WTime.time)
}
inline std::string* WTime::mutable_time() {
  std::string* _s = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:HSS.Times.WTime.time)
  return _s;
}
inline const std::string& WTime::_internal_time() const {
  return _impl_.time_.Get();
}
inline void WTime::_internal_set_time(const std::string& value) {
  
  _impl_.time_.Set(value, GetArenaForAllocation());
}
inline std::string* WTime::_internal_mutable_time() {
  
  return _impl_.time_.Mutable(GetArenaForAllocation());
}
inline std::string* WTime::release_time() {
  // @@protoc_insertion_point(field_release:HSS.Times.WTime.time)
  return _impl_.time_.Release();
}
inline void WTime::set_allocated_time(std::string* time) {
  if (time != nullptr) {
    
  } else {
    
  }
  _impl_.time_.SetAllocated(time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_.IsDefault()) {
    _impl_.time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HSS.Times.WTime.time)
}

// .google.protobuf.StringValue daylight = 2;
inline bool WTime::_internal_has_daylight() const {
  return this != internal_default_instance() && _impl_.daylight_ != nullptr;
}
inline bool WTime::has_daylight() const {
  return _internal_has_daylight();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& WTime::_internal_daylight() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = _impl_.daylight_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& WTime::daylight() const {
  // @@protoc_insertion_point(field_get:HSS.Times.WTime.daylight)
  return _internal_daylight();
}
inline void WTime::unsafe_arena_set_allocated_daylight(
    ::PROTOBUF_NAMESPACE_ID::StringValue* daylight) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.daylight_);
  }
  _impl_.daylight_ = daylight;
  if (daylight) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HSS.Times.WTime.daylight)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* WTime::release_daylight() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.daylight_;
  _impl_.daylight_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* WTime::unsafe_arena_release_daylight() {
  // @@protoc_insertion_point(field_release:HSS.Times.WTime.daylight)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.daylight_;
  _impl_.daylight_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* WTime::_internal_mutable_daylight() {
  
  if (_impl_.daylight_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    _impl_.daylight_ = p;
  }
  return _impl_.daylight_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* WTime::mutable_daylight() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_daylight();
  // @@protoc_insertion_point(field_mutable:HSS.Times.WTime.daylight)
  return _msg;
}
inline void WTime::set_allocated_daylight(::PROTOBUF_NAMESPACE_ID::StringValue* daylight) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.daylight_);
  }
  if (daylight) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(daylight));
    if (message_arena != submessage_arena) {
      daylight = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, daylight, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.daylight_ = daylight;
  // @@protoc_insertion_point(field_set_allocated:HSS.Times.WTime.daylight)
}

// .google.protobuf.StringValue timezone = 3;
inline bool WTime::_internal_has_timezone() const {
  return this != internal_default_instance() && _impl_.timezone_ != nullptr;
}
inline bool WTime::has_timezone() const {
  return _internal_has_timezone();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& WTime::_internal_timezone() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = _impl_.timezone_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& WTime::timezone() const {
  // @@protoc_insertion_point(field_get:HSS.Times.WTime.timezone)
  return _internal_timezone();
}
inline void WTime::unsafe_arena_set_allocated_timezone(
    ::PROTOBUF_NAMESPACE_ID::StringValue* timezone) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timezone_);
  }
  _impl_.timezone_ = timezone;
  if (timezone) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HSS.Times.WTime.timezone)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* WTime::release_timezone() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.timezone_;
  _impl_.timezone_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* WTime::unsafe_arena_release_timezone() {
  // @@protoc_insertion_point(field_release:HSS.Times.WTime.timezone)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = _impl_.timezone_;
  _impl_.timezone_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* WTime::_internal_mutable_timezone() {
  
  if (_impl_.timezone_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    _impl_.timezone_ = p;
  }
  return _impl_.timezone_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* WTime::mutable_timezone() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_timezone();
  // @@protoc_insertion_point(field_mutable:HSS.Times.WTime.timezone)
  return _msg;
}
inline void WTime::set_allocated_timezone(::PROTOBUF_NAMESPACE_ID::StringValue* timezone) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timezone_);
  }
  if (timezone) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timezone));
    if (message_arena != submessage_arena) {
      timezone = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timezone, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timezone_ = timezone;
  // @@protoc_insertion_point(field_set_allocated:HSS.Times.WTime.timezone)
}

// .google.protobuf.Int32Value timezone_id = 4 [deprecated = true];
inline bool WTime::_internal_has_timezone_id() const {
  return this != internal_default_instance() && _impl_.timezone_id_ != nullptr;
}
inline bool WTime::has_timezone_id() const {
  return _internal_has_timezone_id();
}
inline const ::PROTOBUF_NAMESPACE_ID::Int32Value& WTime::_internal_timezone_id() const {
  const ::PROTOBUF_NAMESPACE_ID::Int32Value* p = _impl_.timezone_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Int32Value&>(
      ::PROTOBUF_NAMESPACE_ID::_Int32Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Int32Value& WTime::timezone_id() const {
  // @@protoc_insertion_point(field_get:HSS.Times.WTime.timezone_id)
  return _internal_timezone_id();
}
inline void WTime::unsafe_arena_set_allocated_timezone_id(
    ::PROTOBUF_NAMESPACE_ID::Int32Value* timezone_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timezone_id_);
  }
  _impl_.timezone_id_ = timezone_id;
  if (timezone_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HSS.Times.WTime.timezone_id)
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* WTime::release_timezone_id() {
  
  ::PROTOBUF_NAMESPACE_ID::Int32Value* temp = _impl_.timezone_id_;
  _impl_.timezone_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* WTime::unsafe_arena_release_timezone_id() {
  // @@protoc_insertion_point(field_release:HSS.Times.WTime.timezone_id)
  
  ::PROTOBUF_NAMESPACE_ID::Int32Value* temp = _impl_.timezone_id_;
  _impl_.timezone_id_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* WTime::_internal_mutable_timezone_id() {
  
  if (_impl_.timezone_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Int32Value>(GetArenaForAllocation());
    _impl_.timezone_id_ = p;
  }
  return _impl_.timezone_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::Int32Value* WTime::mutable_timezone_id() {
  ::PROTOBUF_NAMESPACE_ID::Int32Value* _msg = _internal_mutable_timezone_id();
  // @@protoc_insertion_point(field_mutable:HSS.Times.WTime.timezone_id)
  return _msg;
}
inline void WTime::set_allocated_timezone_id(::PROTOBUF_NAMESPACE_ID::Int32Value* timezone_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timezone_id_);
  }
  if (timezone_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timezone_id));
    if (message_arena != submessage_arena) {
      timezone_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timezone_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timezone_id_ = timezone_id;
  // @@protoc_insertion_point(field_set_allocated:HSS.Times.WTime.timezone_id)
}

// -------------------------------------------------------------------

// WTimeSpan

// string time = 1;
inline void WTimeSpan::clear_time() {
  _impl_.time_.ClearToEmpty();
}
inline const std::string& WTimeSpan::time() const {
  // @@protoc_insertion_point(field_get:HSS.Times.WTimeSpan.time)
  return _internal_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WTimeSpan::set_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HSS.Times.WTimeSpan.time)
}
inline std::string* WTimeSpan::mutable_time() {
  std::string* _s = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:HSS.Times.WTimeSpan.time)
  return _s;
}
inline const std::string& WTimeSpan::_internal_time() const {
  return _impl_.time_.Get();
}
inline void WTimeSpan::_internal_set_time(const std::string& value) {
  
  _impl_.time_.Set(value, GetArenaForAllocation());
}
inline std::string* WTimeSpan::_internal_mutable_time() {
  
  return _impl_.time_.Mutable(GetArenaForAllocation());
}
inline std::string* WTimeSpan::release_time() {
  // @@protoc_insertion_point(field_release:HSS.Times.WTimeSpan.time)
  return _impl_.time_.Release();
}
inline void WTimeSpan::set_allocated_time(std::string* time) {
  if (time != nullptr) {
    
  } else {
    
  }
  _impl_.time_.SetAllocated(time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_.IsDefault()) {
    _impl_.time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HSS.Times.WTimeSpan.time)
}

// -------------------------------------------------------------------

// WTimeZone_WTZDetails

// .HSS.Times.WTimeSpan amtTimeZone = 1;
inline bool WTimeZone_WTZDetails::_internal_has_amttimezone() const {
  return this != internal_default_instance() && _impl_.amttimezone_ != nullptr;
}
inline bool WTimeZone_WTZDetails::has_amttimezone() const {
  return _internal_has_amttimezone();
}
inline void WTimeZone_WTZDetails::clear_amttimezone() {
  if (GetArenaForAllocation() == nullptr && _impl_.amttimezone_ != nullptr) {
    delete _impl_.amttimezone_;
  }
  _impl_.amttimezone_ = nullptr;
}
inline const ::HSS::Times::WTimeSpan& WTimeZone_WTZDetails::_internal_amttimezone() const {
  const ::HSS::Times::WTimeSpan* p = _impl_.amttimezone_;
  return p != nullptr ? *p : reinterpret_cast<const ::HSS::Times::WTimeSpan&>(
      ::HSS::Times::_WTimeSpan_default_instance_);
}
inline const ::HSS::Times::WTimeSpan& WTimeZone_WTZDetails::amttimezone() const {
  // @@protoc_insertion_point(field_get:HSS.Times.WTimeZone.WTZDetails.amtTimeZone)
  return _internal_amttimezone();
}
inline void WTimeZone_WTZDetails::unsafe_arena_set_allocated_amttimezone(
    ::HSS::Times::WTimeSpan* amttimezone) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amttimezone_);
  }
  _impl_.amttimezone_ = amttimezone;
  if (amttimezone) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HSS.Times.WTimeZone.WTZDetails.amtTimeZone)
}
inline ::HSS::Times::WTimeSpan* WTimeZone_WTZDetails::release_amttimezone() {
  
  ::HSS::Times::WTimeSpan* temp = _impl_.amttimezone_;
  _impl_.amttimezone_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HSS::Times::WTimeSpan* WTimeZone_WTZDetails::unsafe_arena_release_amttimezone() {
  // @@protoc_insertion_point(field_release:HSS.Times.WTimeZone.WTZDetails.amtTimeZone)
  
  ::HSS::Times::WTimeSpan* temp = _impl_.amttimezone_;
  _impl_.amttimezone_ = nullptr;
  return temp;
}
inline ::HSS::Times::WTimeSpan* WTimeZone_WTZDetails::_internal_mutable_amttimezone() {
  
  if (_impl_.amttimezone_ == nullptr) {
    auto* p = CreateMaybeMessage<::HSS::Times::WTimeSpan>(GetArenaForAllocation());
    _impl_.amttimezone_ = p;
  }
  return _impl_.amttimezone_;
}
inline ::HSS::Times::WTimeSpan* WTimeZone_WTZDetails::mutable_amttimezone() {
  ::HSS::Times::WTimeSpan* _msg = _internal_mutable_amttimezone();
  // @@protoc_insertion_point(field_mutable:HSS.Times.WTimeZone.WTZDetails.amtTimeZone)
  return _msg;
}
inline void WTimeZone_WTZDetails::set_allocated_amttimezone(::HSS::Times::WTimeSpan* amttimezone) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.amttimezone_;
  }
  if (amttimezone) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(amttimezone);
    if (message_arena != submessage_arena) {
      amttimezone = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amttimezone, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.amttimezone_ = amttimezone;
  // @@protoc_insertion_point(field_set_allocated:HSS.Times.WTimeZone.WTZDetails.amtTimeZone)
}

// .HSS.Times.WTimeSpan startDST = 2;
inline bool WTimeZone_WTZDetails::_internal_has_startdst() const {
  return this != internal_default_instance() && _impl_.startdst_ != nullptr;
}
inline bool WTimeZone_WTZDetails::has_startdst() const {
  return _internal_has_startdst();
}
inline void WTimeZone_WTZDetails::clear_startdst() {
  if (GetArenaForAllocation() == nullptr && _impl_.startdst_ != nullptr) {
    delete _impl_.startdst_;
  }
  _impl_.startdst_ = nullptr;
}
inline const ::HSS::Times::WTimeSpan& WTimeZone_WTZDetails::_internal_startdst() const {
  const ::HSS::Times::WTimeSpan* p = _impl_.startdst_;
  return p != nullptr ? *p : reinterpret_cast<const ::HSS::Times::WTimeSpan&>(
      ::HSS::Times::_WTimeSpan_default_instance_);
}
inline const ::HSS::Times::WTimeSpan& WTimeZone_WTZDetails::startdst() const {
  // @@protoc_insertion_point(field_get:HSS.Times.WTimeZone.WTZDetails.startDST)
  return _internal_startdst();
}
inline void WTimeZone_WTZDetails::unsafe_arena_set_allocated_startdst(
    ::HSS::Times::WTimeSpan* startdst) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.startdst_);
  }
  _impl_.startdst_ = startdst;
  if (startdst) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HSS.Times.WTimeZone.WTZDetails.startDST)
}
inline ::HSS::Times::WTimeSpan* WTimeZone_WTZDetails::release_startdst() {
  
  ::HSS::Times::WTimeSpan* temp = _impl_.startdst_;
  _impl_.startdst_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HSS::Times::WTimeSpan* WTimeZone_WTZDetails::unsafe_arena_release_startdst() {
  // @@protoc_insertion_point(field_release:HSS.Times.WTimeZone.WTZDetails.startDST)
  
  ::HSS::Times::WTimeSpan* temp = _impl_.startdst_;
  _impl_.startdst_ = nullptr;
  return temp;
}
inline ::HSS::Times::WTimeSpan* WTimeZone_WTZDetails::_internal_mutable_startdst() {
  
  if (_impl_.startdst_ == nullptr) {
    auto* p = CreateMaybeMessage<::HSS::Times::WTimeSpan>(GetArenaForAllocation());
    _impl_.startdst_ = p;
  }
  return _impl_.startdst_;
}
inline ::HSS::Times::WTimeSpan* WTimeZone_WTZDetails::mutable_startdst() {
  ::HSS::Times::WTimeSpan* _msg = _internal_mutable_startdst();
  // @@protoc_insertion_point(field_mutable:HSS.Times.WTimeZone.WTZDetails.startDST)
  return _msg;
}
inline void WTimeZone_WTZDetails::set_allocated_startdst(::HSS::Times::WTimeSpan* startdst) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.startdst_;
  }
  if (startdst) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(startdst);
    if (message_arena != submessage_arena) {
      startdst = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, startdst, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.startdst_ = startdst;
  // @@protoc_insertion_point(field_set_allocated:HSS.Times.WTimeZone.WTZDetails.startDST)
}

// .HSS.Times.WTimeSpan endDST = 3;
inline bool WTimeZone_WTZDetails::_internal_has_enddst() const {
  return this != internal_default_instance() && _impl_.enddst_ != nullptr;
}
inline bool WTimeZone_WTZDetails::has_enddst() const {
  return _internal_has_enddst();
}
inline void WTimeZone_WTZDetails::clear_enddst() {
  if (GetArenaForAllocation() == nullptr && _impl_.enddst_ != nullptr) {
    delete _impl_.enddst_;
  }
  _impl_.enddst_ = nullptr;
}
inline const ::HSS::Times::WTimeSpan& WTimeZone_WTZDetails::_internal_enddst() const {
  const ::HSS::Times::WTimeSpan* p = _impl_.enddst_;
  return p != nullptr ? *p : reinterpret_cast<const ::HSS::Times::WTimeSpan&>(
      ::HSS::Times::_WTimeSpan_default_instance_);
}
inline const ::HSS::Times::WTimeSpan& WTimeZone_WTZDetails::enddst() const {
  // @@protoc_insertion_point(field_get:HSS.Times.WTimeZone.WTZDetails.endDST)
  return _internal_enddst();
}
inline void WTimeZone_WTZDetails::unsafe_arena_set_allocated_enddst(
    ::HSS::Times::WTimeSpan* enddst) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.enddst_);
  }
  _impl_.enddst_ = enddst;
  if (enddst) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HSS.Times.WTimeZone.WTZDetails.endDST)
}
inline ::HSS::Times::WTimeSpan* WTimeZone_WTZDetails::release_enddst() {
  
  ::HSS::Times::WTimeSpan* temp = _impl_.enddst_;
  _impl_.enddst_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HSS::Times::WTimeSpan* WTimeZone_WTZDetails::unsafe_arena_release_enddst() {
  // @@protoc_insertion_point(field_release:HSS.Times.WTimeZone.WTZDetails.endDST)
  
  ::HSS::Times::WTimeSpan* temp = _impl_.enddst_;
  _impl_.enddst_ = nullptr;
  return temp;
}
inline ::HSS::Times::WTimeSpan* WTimeZone_WTZDetails::_internal_mutable_enddst() {
  
  if (_impl_.enddst_ == nullptr) {
    auto* p = CreateMaybeMessage<::HSS::Times::WTimeSpan>(GetArenaForAllocation());
    _impl_.enddst_ = p;
  }
  return _impl_.enddst_;
}
inline ::HSS::Times::WTimeSpan* WTimeZone_WTZDetails::mutable_enddst() {
  ::HSS::Times::WTimeSpan* _msg = _internal_mutable_enddst();
  // @@protoc_insertion_point(field_mutable:HSS.Times.WTimeZone.WTZDetails.endDST)
  return _msg;
}
inline void WTimeZone_WTZDetails::set_allocated_enddst(::HSS::Times::WTimeSpan* enddst) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.enddst_;
  }
  if (enddst) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(enddst);
    if (message_arena != submessage_arena) {
      enddst = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enddst, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.enddst_ = enddst;
  // @@protoc_insertion_point(field_set_allocated:HSS.Times.WTimeZone.WTZDetails.endDST)
}

// .HSS.Times.WTimeSpan amtDST = 4;
inline bool WTimeZone_WTZDetails::_internal_has_amtdst() const {
  return this != internal_default_instance() && _impl_.amtdst_ != nullptr;
}
inline bool WTimeZone_WTZDetails::has_amtdst() const {
  return _internal_has_amtdst();
}
inline void WTimeZone_WTZDetails::clear_amtdst() {
  if (GetArenaForAllocation() == nullptr && _impl_.amtdst_ != nullptr) {
    delete _impl_.amtdst_;
  }
  _impl_.amtdst_ = nullptr;
}
inline const ::HSS::Times::WTimeSpan& WTimeZone_WTZDetails::_internal_amtdst() const {
  const ::HSS::Times::WTimeSpan* p = _impl_.amtdst_;
  return p != nullptr ? *p : reinterpret_cast<const ::HSS::Times::WTimeSpan&>(
      ::HSS::Times::_WTimeSpan_default_instance_);
}
inline const ::HSS::Times::WTimeSpan& WTimeZone_WTZDetails::amtdst() const {
  // @@protoc_insertion_point(field_get:HSS.Times.WTimeZone.WTZDetails.amtDST)
  return _internal_amtdst();
}
inline void WTimeZone_WTZDetails::unsafe_arena_set_allocated_amtdst(
    ::HSS::Times::WTimeSpan* amtdst) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amtdst_);
  }
  _impl_.amtdst_ = amtdst;
  if (amtdst) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HSS.Times.WTimeZone.WTZDetails.amtDST)
}
inline ::HSS::Times::WTimeSpan* WTimeZone_WTZDetails::release_amtdst() {
  
  ::HSS::Times::WTimeSpan* temp = _impl_.amtdst_;
  _impl_.amtdst_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HSS::Times::WTimeSpan* WTimeZone_WTZDetails::unsafe_arena_release_amtdst() {
  // @@protoc_insertion_point(field_release:HSS.Times.WTimeZone.WTZDetails.amtDST)
  
  ::HSS::Times::WTimeSpan* temp = _impl_.amtdst_;
  _impl_.amtdst_ = nullptr;
  return temp;
}
inline ::HSS::Times::WTimeSpan* WTimeZone_WTZDetails::_internal_mutable_amtdst() {
  
  if (_impl_.amtdst_ == nullptr) {
    auto* p = CreateMaybeMessage<::HSS::Times::WTimeSpan>(GetArenaForAllocation());
    _impl_.amtdst_ = p;
  }
  return _impl_.amtdst_;
}
inline ::HSS::Times::WTimeSpan* WTimeZone_WTZDetails::mutable_amtdst() {
  ::HSS::Times::WTimeSpan* _msg = _internal_mutable_amtdst();
  // @@protoc_insertion_point(field_mutable:HSS.Times.WTimeZone.WTZDetails.amtDST)
  return _msg;
}
inline void WTimeZone_WTZDetails::set_allocated_amtdst(::HSS::Times::WTimeSpan* amtdst) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.amtdst_;
  }
  if (amtdst) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(amtdst);
    if (message_arena != submessage_arena) {
      amtdst = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amtdst, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.amtdst_ = amtdst;
  // @@protoc_insertion_point(field_set_allocated:HSS.Times.WTimeZone.WTZDetails.amtDST)
}

// -------------------------------------------------------------------

// WTimeZone_TZTimeZone

// string name = 1;
inline void WTimeZone_TZTimeZone::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& WTimeZone_TZTimeZone::name() const {
  // @@protoc_insertion_point(field_get:HSS.Times.WTimeZone.TZTimeZone.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WTimeZone_TZTimeZone::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HSS.Times.WTimeZone.TZTimeZone.name)
}
inline std::string* WTimeZone_TZTimeZone::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:HSS.Times.WTimeZone.TZTimeZone.name)
  return _s;
}
inline const std::string& WTimeZone_TZTimeZone::_internal_name() const {
  return _impl_.name_.Get();
}
inline void WTimeZone_TZTimeZone::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* WTimeZone_TZTimeZone::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* WTimeZone_TZTimeZone::release_name() {
  // @@protoc_insertion_point(field_release:HSS.Times.WTimeZone.TZTimeZone.name)
  return _impl_.name_.Release();
}
inline void WTimeZone_TZTimeZone::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HSS.Times.WTimeZone.TZTimeZone.name)
}

// optional bool daylight = 2;
inline bool WTimeZone_TZTimeZone::_internal_has_daylight() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool WTimeZone_TZTimeZone::has_daylight() const {
  return _internal_has_daylight();
}
inline void WTimeZone_TZTimeZone::clear_daylight() {
  _impl_.daylight_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool WTimeZone_TZTimeZone::_internal_daylight() const {
  return _impl_.daylight_;
}
inline bool WTimeZone_TZTimeZone::daylight() const {
  // @@protoc_insertion_point(field_get:HSS.Times.WTimeZone.TZTimeZone.daylight)
  return _internal_daylight();
}
inline void WTimeZone_TZTimeZone::_internal_set_daylight(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.daylight_ = value;
}
inline void WTimeZone_TZTimeZone::set_daylight(bool value) {
  _internal_set_daylight(value);
  // @@protoc_insertion_point(field_set:HSS.Times.WTimeZone.TZTimeZone.daylight)
}

// -------------------------------------------------------------------

// WTimeZone

// int32 version = 1;
inline void WTimeZone::clear_version() {
  _impl_.version_ = 0;
}
inline int32_t WTimeZone::_internal_version() const {
  return _impl_.version_;
}
inline int32_t WTimeZone::version() const {
  // @@protoc_insertion_point(field_get:HSS.Times.WTimeZone.version)
  return _internal_version();
}
inline void WTimeZone::_internal_set_version(int32_t value) {
  
  _impl_.version_ = value;
}
inline void WTimeZone::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:HSS.Times.WTimeZone.version)
}

// int32 timezoneIndex = 2 [deprecated = true];
inline bool WTimeZone::_internal_has_timezoneindex() const {
  return msg_case() == kTimezoneIndex;
}
inline bool WTimeZone::has_timezoneindex() const {
  return _internal_has_timezoneindex();
}
inline void WTimeZone::set_has_timezoneindex() {
  _impl_._oneof_case_[0] = kTimezoneIndex;
}
inline void WTimeZone::clear_timezoneindex() {
  if (_internal_has_timezoneindex()) {
    _impl_.msg_.timezoneindex_ = 0;
    clear_has_msg();
  }
}
inline int32_t WTimeZone::_internal_timezoneindex() const {
  if (_internal_has_timezoneindex()) {
    return _impl_.msg_.timezoneindex_;
  }
  return 0;
}
inline void WTimeZone::_internal_set_timezoneindex(int32_t value) {
  if (!_internal_has_timezoneindex()) {
    clear_msg();
    set_has_timezoneindex();
  }
  _impl_.msg_.timezoneindex_ = value;
}
inline int32_t WTimeZone::timezoneindex() const {
  // @@protoc_insertion_point(field_get:HSS.Times.WTimeZone.timezoneIndex)
  return _internal_timezoneindex();
}
inline void WTimeZone::set_timezoneindex(int32_t value) {
  _internal_set_timezoneindex(value);
  // @@protoc_insertion_point(field_set:HSS.Times.WTimeZone.timezoneIndex)
}

// .HSS.Times.WTimeZone.WTZDetails timezoneDetails = 3 [deprecated = true];
inline bool WTimeZone::_internal_has_timezonedetails() const {
  return msg_case() == kTimezoneDetails;
}
inline bool WTimeZone::has_timezonedetails() const {
  return _internal_has_timezonedetails();
}
inline void WTimeZone::set_has_timezonedetails() {
  _impl_._oneof_case_[0] = kTimezoneDetails;
}
inline void WTimeZone::clear_timezonedetails() {
  if (_internal_has_timezonedetails()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.msg_.timezonedetails_;
    }
    clear_has_msg();
  }
}
inline ::HSS::Times::WTimeZone_WTZDetails* WTimeZone::release_timezonedetails() {
  // @@protoc_insertion_point(field_release:HSS.Times.WTimeZone.timezoneDetails)
  if (_internal_has_timezonedetails()) {
    clear_has_msg();
    ::HSS::Times::WTimeZone_WTZDetails* temp = _impl_.msg_.timezonedetails_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.timezonedetails_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::HSS::Times::WTimeZone_WTZDetails& WTimeZone::_internal_timezonedetails() const {
  return _internal_has_timezonedetails()
      ? *_impl_.msg_.timezonedetails_
      : reinterpret_cast< ::HSS::Times::WTimeZone_WTZDetails&>(::HSS::Times::_WTimeZone_WTZDetails_default_instance_);
}
inline const ::HSS::Times::WTimeZone_WTZDetails& WTimeZone::timezonedetails() const {
  // @@protoc_insertion_point(field_get:HSS.Times.WTimeZone.timezoneDetails)
  return _internal_timezonedetails();
}
inline ::HSS::Times::WTimeZone_WTZDetails* WTimeZone::unsafe_arena_release_timezonedetails() {
  // @@protoc_insertion_point(field_unsafe_arena_release:HSS.Times.WTimeZone.timezoneDetails)
  if (_internal_has_timezonedetails()) {
    clear_has_msg();
    ::HSS::Times::WTimeZone_WTZDetails* temp = _impl_.msg_.timezonedetails_;
    _impl_.msg_.timezonedetails_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WTimeZone::unsafe_arena_set_allocated_timezonedetails(::HSS::Times::WTimeZone_WTZDetails* timezonedetails) {
  clear_msg();
  if (timezonedetails) {
    set_has_timezonedetails();
    _impl_.msg_.timezonedetails_ = timezonedetails;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HSS.Times.WTimeZone.timezoneDetails)
}
inline ::HSS::Times::WTimeZone_WTZDetails* WTimeZone::_internal_mutable_timezonedetails() {
  if (!_internal_has_timezonedetails()) {
    clear_msg();
    set_has_timezonedetails();
    _impl_.msg_.timezonedetails_ = CreateMaybeMessage< ::HSS::Times::WTimeZone_WTZDetails >(GetArenaForAllocation());
  }
  return _impl_.msg_.timezonedetails_;
}
inline ::HSS::Times::WTimeZone_WTZDetails* WTimeZone::mutable_timezonedetails() {
  ::HSS::Times::WTimeZone_WTZDetails* _msg = _internal_mutable_timezonedetails();
  // @@protoc_insertion_point(field_mutable:HSS.Times.WTimeZone.timezoneDetails)
  return _msg;
}

// .HSS.Times.WTimeZone.TZTimeZone tztimezone = 4;
inline bool WTimeZone::_internal_has_tztimezone() const {
  return msg_case() == kTztimezone;
}
inline bool WTimeZone::has_tztimezone() const {
  return _internal_has_tztimezone();
}
inline void WTimeZone::set_has_tztimezone() {
  _impl_._oneof_case_[0] = kTztimezone;
}
inline void WTimeZone::clear_tztimezone() {
  if (_internal_has_tztimezone()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.msg_.tztimezone_;
    }
    clear_has_msg();
  }
}
inline ::HSS::Times::WTimeZone_TZTimeZone* WTimeZone::release_tztimezone() {
  // @@protoc_insertion_point(field_release:HSS.Times.WTimeZone.tztimezone)
  if (_internal_has_tztimezone()) {
    clear_has_msg();
    ::HSS::Times::WTimeZone_TZTimeZone* temp = _impl_.msg_.tztimezone_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.tztimezone_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::HSS::Times::WTimeZone_TZTimeZone& WTimeZone::_internal_tztimezone() const {
  return _internal_has_tztimezone()
      ? *_impl_.msg_.tztimezone_
      : reinterpret_cast< ::HSS::Times::WTimeZone_TZTimeZone&>(::HSS::Times::_WTimeZone_TZTimeZone_default_instance_);
}
inline const ::HSS::Times::WTimeZone_TZTimeZone& WTimeZone::tztimezone() const {
  // @@protoc_insertion_point(field_get:HSS.Times.WTimeZone.tztimezone)
  return _internal_tztimezone();
}
inline ::HSS::Times::WTimeZone_TZTimeZone* WTimeZone::unsafe_arena_release_tztimezone() {
  // @@protoc_insertion_point(field_unsafe_arena_release:HSS.Times.WTimeZone.tztimezone)
  if (_internal_has_tztimezone()) {
    clear_has_msg();
    ::HSS::Times::WTimeZone_TZTimeZone* temp = _impl_.msg_.tztimezone_;
    _impl_.msg_.tztimezone_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WTimeZone::unsafe_arena_set_allocated_tztimezone(::HSS::Times::WTimeZone_TZTimeZone* tztimezone) {
  clear_msg();
  if (tztimezone) {
    set_has_tztimezone();
    _impl_.msg_.tztimezone_ = tztimezone;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HSS.Times.WTimeZone.tztimezone)
}
inline ::HSS::Times::WTimeZone_TZTimeZone* WTimeZone::_internal_mutable_tztimezone() {
  if (!_internal_has_tztimezone()) {
    clear_msg();
    set_has_tztimezone();
    _impl_.msg_.tztimezone_ = CreateMaybeMessage< ::HSS::Times::WTimeZone_TZTimeZone >(GetArenaForAllocation());
  }
  return _impl_.msg_.tztimezone_;
}
inline ::HSS::Times::WTimeZone_TZTimeZone* WTimeZone::mutable_tztimezone() {
  ::HSS::Times::WTimeZone_TZTimeZone* _msg = _internal_mutable_tztimezone();
  // @@protoc_insertion_point(field_mutable:HSS.Times.WTimeZone.tztimezone)
  return _msg;
}

inline bool WTimeZone::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void WTimeZone::clear_has_msg() {
  _impl_._oneof_case_[0] = MSG_NOT_SET;
}
inline WTimeZone::MsgCase WTimeZone::msg_case() const {
  return WTimeZone::MsgCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Times
}  // namespace HSS

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_wtime_2eproto
